### 第一部分：基本操作

#### 基本函数的构建

在这一部分中，我们将完成基本的四则运算和由它们组合而成的初等函数的构建。你需要在cc/operators中补全`ops.h`和`ops.cc`的内容。

在`ops.h`中，你需要补全以下函数的实现：

- `mul`函数，输入为两个数`a`、`b`，输出为它们的乘积。

- `id`函数，将输入原样输出。

- `add`函数，输入为两个数`a`、`b`，输出为它们的和。

- `neg`函数，输入为`a`，输出为`-a`。

- `lt`函数，输入为两个数`a`、`b`，输出为`(float)(a < b)`。

- `eq`函数，输入为两个数`a`、`b`，输出为`(float)(a == b)`。

- `max`函数，输入为两个数`a`、`b`，输出为`a`和`b`中较大的那个。

它们都是模板函数，相信你已经注意到了，它们都被定义在`.h`文件中，而不是`.cc`文件中，这与C++的模板的实例化机制和编译模型有关。

模板的实例化机制：模板函数或模板类并不是真正的代码，而是一个“蓝图”或“模式”，编译器在编译时根据这个蓝图生成具体的代码。这个过程称为模板实例化。例如，当你使用一个模板函数时，编译器会根据你传递的类型参数生成一个具体的函数版本。这个生成的过程发生在编译时。

编译模型：C++采用的是分离编译模型，即每个源文件（.cc 或 .cpp 文件）是独立编译的。编译器在编译一个源文件时，只会看到该源文件及其包含的头文件中的内容。如果你将模板函数的定义放在源文件中，其他源文件在编译时无法看到模板的定义，因此无法生成对应的实例化代码。

另外，你应当还注意到了我们为这两个文件提供了名叫`operators`的命名空间（namespace）。主要是为了防止不同命名空间中的重名冲突。

在`ops.cc`中，你需要完成以下函数的实现：

- `is_close`函数，输入为两个数`x`、`y`，输出为`(float)(abs(x - y) < epsilon)`。

- `sigmoid`函数，输入为`x`，为了方便计算，在输出时遵照下面的规则：

$$
f(x) =\left\{\begin{matrix}
\frac{1.0}{(1.0 + e^{-x})}, x\ge 0
 \\
\frac{e^x}{(1.0 + e^{x})}, \mathrm{otherwise}
\end{matrix}\right.
$$

- `relu`函数，输入为`x`，输出为`x > 0.0 ? x : 0.0`。

- `inv`函数，输入为`x`，输出为`1.0 / x`。

- `inv_back`函数，用于计算$f(x)=\frac{1}{x}$的微分$f(x)\mathrm{d}x$，输入为`x`和`d`，输出为$-\frac{d}{x^2}$。

- `relu_back`函数，输入为`x`和`d`，输出为`x > 0.0 ? d*1.0 : 0.0`。

